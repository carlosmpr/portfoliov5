---
import "../styles/global.css";
import Navbar from '../components/Navbar.astro';
import Footer from '../components/Footer.astro';

// The ViewTransitions component from Astro handles all the magic!
import { ClientRouter } from 'astro:transitions';

interface Props {
	title: string;
	description: string;
	currentPage: 'home' | 'work';
}

const { title, description, currentPage } = Astro.props;
---
<html lang="en">
<head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <meta name="keywords" content="contact, Carlos Polanco, hire developer, project inquiry, collaboration" />
    <meta property="og:title" content="Contact - Carlos Polanco" />
    <meta property="og:description" content={description} />
    <meta property="og:type" content="website" />
    <title>{title}</title>
    
    {/* This component enables the page transitions */}
    <ClientRouter />
    
    <style is:global>
   <style is:global>
    /* This animation creates a modern slideshow effect.
       The old page slides to the left and fades out.
       The new page slides in from the right and fades in.
    */

    /* Animation for the OLD page content (sliding out) */
    ::view-transition-old(root) {
        animation: slide-out 0.45s cubic-bezier(0.4, 0, 0.2, 1) both;
    }

    /* Animation for the NEW page content (sliding in) */
    ::view-transition-new(root) {
        animation: slide-in 0.45s cubic-bezier(0.4, 0, 0.2, 1) both;
    }

    /* Keyframe for the old page sliding out to the left */
    @keyframes slide-out {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(-50px); /* Moves left */
            opacity: 0;
        }
    }

    /* Keyframe for the new page sliding in from the right */
    @keyframes slide-in {
        from {
            transform: translateX(50px); /* Starts from the right */
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
</style>
    </style>
</head>
<body class="bg-neutral-950 text-white font-sans antialiased overflow-x-hidden">
    <Navbar {currentPage} />

    {/* The <slot /> will render the content of each individual page */}
    <slot />

    <Footer />

    <script>
        // Centralized script management for all components
        async function runPageScripts() {
            initScrollAnimations();
            initAboutMeAnimations();
            initTechnologiesAnimations();
            initAIAnimations();
            initVideoStack();
            
            // Initialize GSAP-powered animations
            await initGSAPAnimations();
        }

        // FeaturedWork & AboutMe & Technologies & AI Agents - Scroll animations
        function initScrollAnimations() {
            const elements = document.querySelectorAll('.animate-slide-up');
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                        observer.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            });

            elements.forEach((element) => {
                observer.observe(element);
            });
        }

        // AboutMe specific animations
        function initAboutMeAnimations() {
            initScrollAnimations(); // Reuse scroll animations
        }

        // Technologies specific animations
        function initTechnologiesAnimations() {
            initScrollAnimations(); // Reuse scroll animations
        }

        // AI Agents specific animations
        function initAIAnimations() {
            initScrollAnimations(); // Reuse scroll animations
        }

        // AboutMe - Video stack functionality
        function initVideoStack() {
            const videoStack = document.getElementById('videoStack');
            if (!videoStack) return;

            let currentVideo = 0;
            const videos = document.querySelectorAll('.video-item');
            const indicators = document.querySelectorAll('.indicator');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const totalVideos = videos.length;

            if (totalVideos === 0) return;

            function updateVideoDisplay() {
                videos.forEach((video, index) => {
                    video.classList.remove('active', 'prev');
                    if (indicators[index]) indicators[index].classList.remove('active');
                    
                    if (index === currentVideo) {
                        video.classList.add('active');
                        if (indicators[index]) indicators[index].classList.add('active');
                    } else if (index === currentVideo - 1 || (currentVideo === 0 && index === totalVideos - 1)) {
                        video.classList.add('prev');
                    }
                });
            }

            function nextVideo() {
                currentVideo = (currentVideo + 1) % totalVideos;
                updateVideoDisplay();
            }

            function prevVideo() {
                currentVideo = (currentVideo - 1 + totalVideos) % totalVideos;
                updateVideoDisplay();
            }

            function goToVideo(index) {
                currentVideo = index;
                updateVideoDisplay();
            }

            // Event listeners
            if (nextBtn) nextBtn.addEventListener('click', nextVideo);
            if (prevBtn) prevBtn.addEventListener('click', prevVideo);
            
            indicators.forEach((indicator, index) => {
                indicator.addEventListener('click', () => goToVideo(index));
            });

            // Initialize display
            updateVideoDisplay();
        }

        // GSAP-powered animations
        async function initGSAPAnimations() {
            // Load GSAP dynamically
            function loadGSAP() {
                return new Promise((resolve) => {
                    if (window.gsap) {
                        resolve(window.gsap);
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js';
                    script.onload = () => resolve(window.gsap);
                    script.onerror = () => resolve(null);
                    document.head.appendChild(script);
                });
            }

            const gsap = await loadGSAP();
            
            // Initialize slideshow animations (work page)
            initSlideshowAnimations(gsap);
            
            // Initialize featured work animations (home page)  
            initFeaturedWorkAnimations(gsap);
        }

        // Slideshow animations
        function initSlideshowAnimations(gsap) {
            const track = document.getElementById('slideshow-track');
            const prevBtn = document.getElementById('slideshow-prevBtn');
            const nextBtn = document.getElementById('slideshow-nextBtn');
            const tabs = document.getElementById('slideshow-tabs');
            const underline = document.getElementById('slideshow-underline');
            
            if (!track) return; // Not on work page

            const useGSAP = !!gsap;
            const slides = Array.from(track.querySelectorAll('.slide'));
            const count = slides.length;
            let index = 0;
            let autoAdvanceInterval;
            let isAnimating = false;

            if (!useGSAP) {
                document.body.classList.add('css-animations');
                console.log('GSAP not available, using CSS fallback animations for Slideshow');
            } else {
                console.log('GSAP loaded successfully, using enhanced animations for Slideshow');
            }

            function setTrackWidth() {
                track.style.width = `${count * 100}%`;
                slides.forEach(s => s.style.width = `${100 / count}%`);
            }

            function setIndex(i, direction = 1) {
                if (isAnimating) return;
                
                const prevIndex = index;
                index = (i + count) % count;
                
                if (prevIndex === index) return;
                
                isAnimating = true;

                if (useGSAP) {
                    // Enhanced GSAP Animations
                    const masterTL = gsap.timeline({
                        onComplete: () => {
                            isAnimating = false;
                            updateTabs();
                        }
                    });

                    // Track movement - faster and snappier
                    masterTL.to(track, {
                        x: `-${index * (100 / count)}%`,
                        duration: 0.7,
                        ease: "power3.out"
                    }, 0);

                    // Previous slide content out
                    const prevSlideContent = slides[prevIndex]?.querySelector('.slide-content');
                    if (prevSlideContent) {
                        masterTL.to(prevSlideContent, {
                            opacity: 0,
                            y: direction > 0 ? -25 : 25,
                            scale: 0.96,
                            duration: 0.3,
                            ease: "power2.in"
                        }, 0);
                    }

                    // New slide content in with stagger
                    const newSlideContent = slides[index]?.querySelector('.slide-content');
                    if (newSlideContent) {
                        const contentElements = newSlideContent.children;
                        
                        gsap.set(newSlideContent, { opacity: 0 });
                        gsap.set(contentElements, { 
                            opacity: 0, 
                            y: direction > 0 ? 40 : -40,
                            scale: 0.95
                        });

                        masterTL.to(newSlideContent, {
                            opacity: 1,
                            duration: 0.2,
                            ease: "power2.out"
                        }, 0.2);

                        masterTL.to(contentElements, {
                            opacity: 1,
                            y: 0,
                            scale: 1,
                            duration: 0.5,
                            stagger: 0.08,
                            ease: "back.out(1.2)"
                        }, 0.3);
                    }

                    // Background effects
                    const prevSlide = slides[prevIndex];
                    const newSlide = slides[index];
                    
                    if (prevSlide && newSlide) {
                        const prevBg = prevSlide.querySelector('.absolute.inset-0');
                        const newBg = newSlide.querySelector('.absolute.inset-0');
                        
                        if (prevBg) {
                            masterTL.to(prevBg, {
                                scale: 1.05,
                                rotation: direction > 0 ? 1.5 : -1.5,
                                duration: 0.7,
                                ease: "power2.out"
                            }, 0);
                        }
                        
                        if (newBg) {
                            gsap.set(newBg, { scale: 0.95, rotation: direction > 0 ? -1.5 : 1.5 });
                            masterTL.to(newBg, {
                                scale: 1,
                                rotation: 0,
                                duration: 0.7,
                                ease: "power2.out"
                            }, 0.1);
                        }
                    }
                } else {
                    // CSS Fallback Animations
                    track.style.transform = `translateX(-${index * (100 / count)}%)`;
                    track.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    
                    const prevSlideContent = slides[prevIndex]?.querySelector('.slide-content');
                    const newSlideContent = slides[index]?.querySelector('.slide-content');
                    
                    if (prevSlideContent) {
                        prevSlideContent.classList.remove('visible');
                    }
                    
                    setTimeout(() => {
                        if (newSlideContent) {
                            newSlideContent.classList.add('visible');
                        }
                        isAnimating = false;
                        updateTabs();
                    }, 200);
                }
            }

            function createTabs() {
                tabs.innerHTML = '<div id="slideshow-underline" class="tab-underline absolute bottom-0 h-0.5 bg-blue-400"></div>';
                
                for (let i = 0; i < count; i++) {
                    const btn = document.createElement('button');
                    btn.id = `slideshow-tab-${i}`;
                    btn.className = 'mx-2 px-4 py-2 text-sm rounded-full text-white/60 data-[active=true]:text-blue-400 focus:outline-none border border-white/10 hover:border-white/20 transition-all transform hover:scale-105';
                    btn.textContent = String(i + 1);
                    btn.setAttribute('aria-label', `Go to slide ${i + 1}`);
                    btn.addEventListener('click', () => {
                        if (!isAnimating) {
                            stopAutoAdvance();
                            const direction = i > index ? 1 : -1;
                            setIndex(i, direction);
                            setTimeout(startAutoAdvance, 2000);
                        }
                    });
                    tabs.appendChild(btn);
                }
            }

            function updateTabs() {
                const buttons = tabs.querySelectorAll('button');
                buttons.forEach((b, i) => {
                    b.dataset.active = String(i === index);
                    b.setAttribute('aria-selected', String(i === index));
                });
                
                const activeTab = document.getElementById(`slideshow-tab-${index}`);
                const newUnderline = document.getElementById('slideshow-underline');
                
                if (activeTab && newUnderline) {
                    const parentLeft = tabs.getBoundingClientRect().left;
                    const { left, width } = activeTab.getBoundingClientRect();
                    
                    if (useGSAP) {
                        gsap.to(newUnderline, {
                            x: left - parentLeft,
                            width: width,
                            duration: 0.3,
                            ease: "power2.out"
                        });
                    } else {
                        newUnderline.style.transform = `translateX(${left - parentLeft}px)`;
                        newUnderline.style.width = `${width}px`;
                    }
                }
            }

            function startAutoAdvance() {
                autoAdvanceInterval = setInterval(() => {
                    if (!isAnimating) {
                        setIndex(index + 1, 1);
                    }
                }, 4500);
            }
            
            function stopAutoAdvance() {
                if (autoAdvanceInterval) {
                    clearInterval(autoAdvanceInterval);
                }
            }

            // Event listeners
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (!isAnimating) {
                        stopAutoAdvance();
                        setIndex(index - 1, -1);
                        setTimeout(startAutoAdvance, 1000);
                    }
                });
                
                if (useGSAP) {
                    prevBtn.addEventListener('mouseenter', () => {
                        gsap.to(prevBtn, { scale: 1.1, duration: 0.2, ease: "back.out(1.4)" });
                    });
                    prevBtn.addEventListener('mouseleave', () => {
                        gsap.to(prevBtn, { scale: 1, duration: 0.2, ease: "power2.out" });
                    });
                }
            }

            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (!isAnimating) {
                        stopAutoAdvance();
                        setIndex(index + 1, 1);
                        setTimeout(startAutoAdvance, 1000);
                    }
                });
                
                if (useGSAP) {
                    nextBtn.addEventListener('mouseenter', () => {
                        gsap.to(nextBtn, { scale: 1.1, duration: 0.2, ease: "back.out(1.4)" });
                    });
                    nextBtn.addEventListener('mouseleave', () => {
                        gsap.to(nextBtn, { scale: 1, duration: 0.2, ease: "power2.out" });
                    });
                }
            }

            // Container hover effects
            const slideshow = document.querySelector('.slideshow-container');
            if (slideshow) {
                slideshow.addEventListener('mouseenter', () => {
                    stopAutoAdvance();
                    if (useGSAP) {
                        gsap.to(slideshow, { scale: 1.005, duration: 0.3, ease: "power2.out" });
                    }
                });
                slideshow.addEventListener('mouseleave', () => {
                    startAutoAdvance();
                    if (useGSAP) {
                        gsap.to(slideshow, { scale: 1, duration: 0.3, ease: "power2.out" });
                    }
                });
            }

            // Keyboard navigation
            const keydownHandler = (e) => {
                if (isAnimating) return;
                
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    stopAutoAdvance();
                    setIndex(index - 1, -1);
                    setTimeout(startAutoAdvance, 1000);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    stopAutoAdvance();
                    setIndex(index + 1, 1);
                    setTimeout(startAutoAdvance, 1000);
                }
            };

            document.addEventListener('keydown', keydownHandler);

            // Initialize
            if (count > 0) {
                setTrackWidth();
                createTabs();
                
                // Initial setup
                const allSlideContents = document.querySelectorAll('.slide-content');
                
                if (useGSAP) {
                    gsap.set(allSlideContents, { opacity: 0 });
                    
                    setTimeout(() => {
                        const firstSlideContent = slides[0]?.querySelector('.slide-content');
                        if (firstSlideContent) {
                            const contentElements = firstSlideContent.children;
                            
                            gsap.set(firstSlideContent, { opacity: 1 });
                            gsap.fromTo(contentElements, 
                                { 
                                    opacity: 0, 
                                    y: 50,
                                    scale: 0.9
                                },
                                { 
                                    opacity: 1, 
                                    y: 0,
                                    scale: 1,
                                    duration: 0.8,
                                    stagger: 0.1,
                                    ease: "back.out(1.2)",
                                    delay: 0.2
                                }
                            );
                        }
                        updateTabs();
                    }, 400);
                } else {
                    allSlideContents.forEach((content, i) => {
                        if (i === 0) {
                            content.classList.add('visible');
                        }
                    });
                    updateTabs();
                }
                
                setTimeout(startAutoAdvance, useGSAP ? 1500 : 1000);
            }
        }

        // Featured Work Tetris animations
        function initFeaturedWorkAnimations(gsap) {
            const useGSAP = !!gsap;

            if (!useGSAP) {
                // Fallback to CSS animations
                document.body.classList.add('css-animations');
                console.log('GSAP not available, using CSS fallback animations for FeaturedWork');
                
                // Trigger CSS animations with IntersectionObserver
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('is-visible');
                            observer.unobserve(entry.target);
                        }
                    });
                }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });

                document.querySelectorAll('.tetris-header, .tetris-card, .tetris-button').forEach((el) => {
                    observer.observe(el);
                });
                return;
            }

            console.log('GSAP loaded, creating Tetris-style animations for FeaturedWork');

            // Create Tetris-style entrance animations
            function createTetrisAnimation() {
                const header = document.querySelector('.tetris-header');
                const cards = document.querySelectorAll('.tetris-card');
                const button = document.querySelector('.tetris-button');

                if (!header || !cards.length) return;

                // Create master timeline
                const masterTL = gsap.timeline({ paused: true });

                // 1. Header slides in from top like a Tetris piece dropping
                if (header) {
                    gsap.set(header, { 
                        opacity: 0, 
                        visibility: 'visible',
                        y: -100,
                        scale: 0.9,
                        rotationX: -15
                    });

                    masterTL.to(header, {
                        opacity: 1,
                        y: 0,
                        scale: 1,
                        rotationX: 0,
                        duration: 0.8,
                        ease: "back.out(1.2)",
                        onStart: () => {
                            // Add a subtle bounce effect
                            gsap.to(header, {
                                y: -10,
                                duration: 0.15,
                                yoyo: true,
                                repeat: 1,
                                ease: "power2.out",
                                delay: 0.6
                            });
                        }
                    }, 0.2);
                }

                // 2. Cards animate in like Tetris blocks from different sides
                cards.forEach((card, index) => {
                    const isLargeCard = index === 0; // First card is the large one
                    
                    // Set initial positions based on card layout
                    let fromX, fromY, fromRotation;
                    
                    if (isLargeCard) {
                        // Large card slides in from left like an L-piece
                        fromX = -300;
                        fromY = 50;
                        fromRotation = -5;
                    } else {
                        // Smaller cards come from different directions like Tetris pieces
                        const directions = [
                            { x: 200, y: -80, rotation: 3 },   // From top-right
                            { x: -150, y: 100, rotation: -2 }, // From bottom-left  
                            { x: 180, y: 120, rotation: 4 },   // From bottom-right
                            { x: -200, y: -50, rotation: -3 }  // From top-left
                        ];
                        const direction = directions[(index - 1) % directions.length];
                        fromX = direction.x;
                        fromY = direction.y;
                        fromRotation = direction.rotation;
                    }

                    gsap.set(card, { 
                        opacity: 0, 
                        visibility: 'visible',
                        x: fromX,
                        y: fromY,
                        scale: 0.8,
                        rotation: fromRotation
                    });

                    // Animate to final position with Tetris-like movement
                    masterTL.to(card, {
                        opacity: 1,
                        x: 0,
                        y: 0,
                        scale: 1,
                        rotation: 0,
                        duration: 0.7,
                        ease: "power3.out",
                        onComplete: () => {
                            // Add landing effect like Tetris piece placement
                            gsap.to(card, {
                                scale: 1.02,
                                duration: 0.1,
                                yoyo: true,
                                repeat: 1,
                                ease: "power2.out"
                            });
                            
                            // Add slight shake effect
                            gsap.to(card, {
                                x: gsap.utils.random(-2, 2),
                                duration: 0.05,
                                yoyo: true,
                                repeat: 3,
                                ease: "power2.out"
                            });
                        }
                    }, 0.4 + (index * 0.15));

                    // Animate internal elements (tags, text) with stagger
                    const cardElements = card.querySelectorAll('h3, p, .project-tag, .project-number');
                    if (cardElements.length) {
                        gsap.set(cardElements, { 
                            opacity: 0, 
                            y: 20,
                            scale: 0.95
                        });

                        masterTL.to(cardElements, {
                            opacity: 1,
                            y: 0,
                            scale: 1,
                            duration: 0.5,
                            stagger: 0.08,
                            ease: "back.out(1.1)"
                        }, 0.6 + (index * 0.15));
                    }
                });

                // 3. Button drops in from above like final Tetris piece
                if (button) {
                    gsap.set(button, { 
                        opacity: 0, 
                        visibility: 'visible',
                        y: -60,
                        scale: 0.8,
                        rotation: 2
                    });

                    masterTL.to(button, {
                        opacity: 1,
                        y: 0,
                        scale: 1,
                        rotation: 0,
                        duration: 0.6,
                        ease: "bounce.out",
                        onComplete: () => {
                            // Add glow effect
                            gsap.to(button, {
                                boxShadow: "0 0 20px rgba(59, 130, 246, 0.3)",
                                duration: 0.3,
                                yoyo: true,
                                repeat: 1
                            });
                        }
                    }, 1.8);
                }

                return masterTL;
            }

            // Setup Intersection Observer to trigger animation
            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const tetrisTimeline = createTetrisAnimation();
                        if (tetrisTimeline) {
                            tetrisTimeline.play();
                        }
                        observer.unobserve(entry.target);
                    }
                });
            }, { 
                threshold: 0.2,
                rootMargin: '0px 0px -100px 0px'
            });

            // Observe the header to trigger the animation
            const header = document.querySelector('.tetris-header');
            if (header) {
                observer.observe(header);
            }

            // Add enhanced hover effects for cards
            const cards = document.querySelectorAll('.tetris-card');
            cards.forEach((card) => {
                card.addEventListener('mouseenter', () => {
                    gsap.to(card, {
                        y: -8,
                        scale: 1.02,
                        duration: 0.3,
                        ease: "power2.out"
                    });
                    
                    // Animate internal elements
                    const elements = card.querySelectorAll('.project-tag');
                    gsap.to(elements, {
                        scale: 1.05,
                        duration: 0.2,
                        stagger: 0.05,
                        ease: "power2.out"
                    });
                });

                card.addEventListener('mouseleave', () => {
                    gsap.to(card, {
                        y: 0,
                        scale: 1,
                        duration: 0.3,
                        ease: "power2.out"
                    });
                    
                    const elements = card.querySelectorAll('.project-tag');
                    gsap.to(elements, {
                        scale: 1,
                        duration: 0.2,
                        stagger: 0.05,
                        ease: "power2.out"
                    });
                });
            });
        }


        // Run scripts on initial load
        document.addEventListener('DOMContentLoaded', runPageScripts);

        // Re-run scripts after page transitions
        document.addEventListener('astro:after-swap', runPageScripts);


        
    </script>
</body>
</html>